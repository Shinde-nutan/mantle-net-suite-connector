<?xml version="1.0" encoding="UTF-8"?>
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-3.xsd">
    <service verb="generate" noun="NewOrdersSyncFeed" authenticate="anonymous-all" transaction-timeout="7200">
        <in-parameters>
            <parameter name="orderId">
                <description>Parameter to fetch Order details for a specific orderId.</description>
            </parameter>
            <parameter name="systemMessageTypeId" required="true">
                <description>The System Message Type ID for generating the Orders Feed for Netsuite.</description>
            </parameter>
            <parameter name="systemMessageRemoteId" required="true">
                <description>The System Message Remote Id for generating the Orders Feed for Netsuite.</description>
            </parameter>
            <parameter name="fromOrderDate">
                <description>Parameter to fetch Order details after specific order date</description>
            </parameter>
            <parameter name="thruOrderDate">
                <description>Parameter to fetch Order details after specific order date</description>
            </parameter>
            <parameter name="includeShipmentMethod" type="List">
                <description>
                    Parameter to fetch Order details for specific shipment method or a list of shipping method
                    like: POS_COMPLETED,STORE_PICKUP
                </description>
            </parameter>
            <parameter name="excludeShipmentMethod" type="List">
                <description>Parameter to exclude the Orders from the specific shipment method or a list of shipping method
                    like: POS_COMPLETED,STORE_PICKUP
                </description>
            </parameter>
            <parameter name="includeSalesChannel" type="List">
                <description>Parameter to fetch Order details for specific sales channel or a list of sales channel.</description>
            </parameter>
            <parameter name="excludeSalesChannel" type="List">
                <description>Parameter to exclude the Orders from the specific sales channel or a list of sales channel.</description>
            </parameter>
            <parameter name="isMixCartOrder">
                <description>
                    Parameter to include or exclude the orders which have multiple shipping methods.
                    Example: Y to include the order with multiple shipping methods.
                    N to not include the order with multiple shipping methods.
                </description>
            </parameter>
            <parameter name="isCashOrderFeed">
                <description>
                    Parameter to determine if the feed is for cash orders or not.
                    Need to configure this as the same service is used for both sales orders and cash sales orders.
                    if set to 'Y' then the feed is for cash orders and if set to 'N' then the feed is for sales orders.
                </description>
            </parameter>
        </in-parameters>
        <actions>
            <set field="nowTimestamp" from="ec.user.nowTimestamp"/>
            <log message="Generating Order Feed file for Order ${orderId} at time ${nowTimestamp}"/>

            <entity-find-one entity-name="moqui.service.message.SystemMessageType" value-field="systemMessageType"/>
            <if condition="systemMessageType == null">
                <return error="true" message="Could not find SystemMessageType with ID ${systemMessageTypeId}"/>
            </if>
            <script>
                import org.apache.commons.csv.CSVFormat
                import org.apache.commons.csv.CSVPrinter
                import java.nio.file.Files
                import java.nio.file.Paths
                import java.nio.charset.StandardCharsets
                import org.moqui.entity.EntityCondition
                import co.hotwax.common.SchemaValidation
                import co.hotwax.netsuite.NetSuiteMappingWorker

                netsuiteOrders_find = ec.entity.find("co.hotwax.netsuite.order.EligibleOrders")
                if(orderId) netsuiteOrders_find.condition("orderId", orderId)
                if(fromOrderDate) netsuiteOrders_find.condition("orderDate", EntityCondition.ComparisonOperator.GREATER_THAN, fromOrderDate)
                if(thruOrderDate) netsuiteOrders_find.condition("orderDate", EntityCondition.ComparisonOperator.LESS_THAN, fromOrderDate)
                if(includeShipmentMethod) netsuiteOrders_find.condition("shipmentMethodTypeId",EntityCondition.ComparisonOperator.IN, includeShipmentMethod)
                if(excludeShipmentMethod) netsuiteOrders_find.condition("shipmentMethodTypeId",EntityCondition.ComparisonOperator.NOT_IN, excludeShipmentMethod)
                if(includeSalesChannel) netsuiteOrders_find.condition("salesChannelEnumId",EntityCondition.ComparisonOperator.IN, includeSalesChannel)
                if(excludeSalesChannel) netsuiteOrders_find.condition("salesChannelEnumId",EntityCondition.ComparisonOperator.NOT_IN, excludeSalesChannel)

                // Add conditions based on isCashOrderFeed parameter
                if (isCashOrderFeed == "Y") {
                    netsuiteOrders_find.condition("nonPosCompletedItemsCount", EntityCondition.ComparisonOperator.EQUALS, 0)
                } else if (isCashOrderFeed == "N") {
                    netsuiteOrders_find.condition("nonPosCompletedItemsCount", EntityCondition.ComparisonOperator.GREATER_THAN, 0)
                }

                netsuiteOrders_find.selectField("orderId,partyId,netsuiteCustomerId,orderDate,isMixCartOrder")
                netsuiteOrders_find.distinct(true)

                //If no eligible orders, then don't generate the file
                long netsuiteOrdersCount = netsuiteOrders_find.count()
                if (netsuiteOrdersCount == 0) {
                    ec.message.addMessage("No eligible orders at ${nowTimestamp}, not generating the HotWax Feed file for Netsuite.")
                    return
                }
            </script>
            <entity-find-one entity-name="moqui.service.message.SystemMessageTypeParameter" value-field="groovyFileResource">
                <field-map field-name="systemMessageTypeId" from="systemMessageTypeId"/>
                <field-map field-name="parameterName" value="resourcePath"/>
            </entity-find-one>
            <!-- Check if the Groovy file resource is available. -->
            <if condition="groovyFileResource &amp;&amp; groovyFileResource.parameterValue">
                <set field="scriptPath" from="groovyFileResource.parameterValue"/>
            </if>
            <entity-find-one entity-name="moqui.service.message.SystemMessageTypeParameter" value-field="schemaPath">
                <field-map field-name="systemMessageTypeId" from="systemMessageTypeId"/>
                <field-map field-name="parameterName" value="schemaPath"/>
            </entity-find-one>
            <if condition="schemaPath">
                <set field="schemaLocation" from="schemaPath.parameterValue" type="String"/>
                <else><set field="schemaLocation" value="component://mantle-netsuite-connector/schemas/DefaultOrderSchema.json"/></else>
            </if>

            <entity-find-one entity-name="moqui.basic.Enumeration" value-field="enumValue">
                <field-map field-name="enumId" from="systemMessageTypeId"/>
            </entity-find-one>

            <if condition="enumValue &amp;&amp; enumValue.relatedEnumId">
            <entity-find-one entity-name="moqui.service.message.SystemMessageType" value-field="relatedSystemMessageType">
                <field-map field-name="systemMessageTypeId" from="enumValue.relatedEnumId"/>
            </entity-find-one>

            <!-- Prepare csv File Path -->
            <set field="csvFilePathRef" from="ec.resource.expand(systemMessageType.receivePath, null,
            [contentRoot: ec.user.getPreference('mantle.content.root') ?: 'dbresource://datamanager', date:ec.l10n.format(nowTimestamp, 'yyyy-MM-dd'), dateTime:ec.l10n.format(nowTimestamp, 'yyyy-MM-dd-HH-mm-ss-SSS'),
             productStoreId:productStoreId], false)"/>
            <set field="csvFilePath" from="ec.resource.getLocationReference(csvFilePathRef).getUri().getPath()"/>

            <!-- Prepare csv File Path -->
            <set field="invalidFilePathRef" from="ec.resource.expand(relatedSystemMessageType.receivePath, null,
            [contentRoot: ec.user.getPreference('mantle.content.root') ?: 'dbresource://datamanager', date:ec.l10n.format(nowTimestamp, 'yyyy-MM-dd'), dateTime:ec.l10n.format(nowTimestamp, 'yyyy-MM-dd-HH-mm-ss-SSS'),
             productStoreId:productStoreId], false)"/>
            <set field="invalidFilePath" from="ec.resource.getLocationReference(invalidFilePathRef).getUri().getPath()"/>

            <set field="flattenedOrders" from="[]" type="List"/>
            <script>
                File csvFile = new File(csvFilePath)
                File invalidFile = new File(invalidFilePath)
                if (!csvFile.parentFile.exists()) csvFile.parentFile.mkdirs()
                if (!invalidFile.parentFile.exists()) invalidFile.parentFile.mkdirs()
                isReqFieldMissFileEmpty = true
                isFileEmpty = true
                csvHeaders = null

                // Using try-with-resources to automatically close the EntityListIterator 'ordersItr'
                try (ordersItr = netsuiteOrders_find.iterator()) {
                     try (def writer = Files.newBufferedWriter(Paths.get(csvFilePath), StandardCharsets.UTF_8);
                        def invalidWriter = Files.newBufferedWriter(Paths.get(invalidFilePath), StandardCharsets.UTF_8);
                        def csvPrinter = new CSVPrinter(writer, CSVFormat.DEFAULT);
                        def invalidCsvPrinter = new CSVPrinter(invalidWriter, CSVFormat.DEFAULT)) {
            </script>

            <iterate list="ordersItr" entry="order">
                <entity-find-one entity-name="co.hotwax.netsuite.order.OrderDetails" value-field="orderDetails">
                    <field-map field-name="orderId" from="order.orderId"/>
                </entity-find-one>
                <set field="orderDetails" from="orderDetails.getPlainValueMap(0)"/>

                <set field="orderDetails.shippingCost" from="orderDetails.shippingCost ?: BigDecimal.ZERO"/>
                <set field="orderDetails.date" from="ec.l10n.format(orderDetails.date, 'MM/dd/yyyy')"/>

                <set field="orderDetails.billingPhone" from="((orderDetails.billingCountryCode?:'') || (orderDetails.billingAreaCode?:'') || (orderDetails.billingContactNumber?:'')) ? ((orderDetails.billingCountryCode ?:'') + ' ' + (orderDetails.billingAreaCode ?:'') + ' ' + (orderDetails.billingContactNumber ?:'')) : ''" />
                <set field="orderDetails.phone" from="((orderDetails.shippingCountryCode?:'') || (orderDetails.shippingAreaCode?:'') || (orderDetails.shippingContactNumber?:'')) ? ((orderDetails.shippingCountryCode ?:'') + ' ' + (orderDetails.shippingAreaCode ?:'') + ' ' + (orderDetails.shippingContactNumber ?:'')) : ''" />

                <if condition="(!orderDetails.billingContactMechId &amp;&amp; orderDetails.shippingContactMechId)">
                    <set field="orderDetails" from="orderDetails + [billingAddress1:orderDetails.address1, billingAddress2:orderDetails.address2, billingCity:orderDetails.city, billingState:orderDetails.state, billingCountry:orderDetails.country, billingZip:orderDetails.zip]"/>
                    <else><set field="orderDetails" from="orderDetails + [billingAddress1:orderDetails.billingAddress1, billingAddress2:orderDetails.billingAddress2, billingCity:orderDetails.billingCity, billingState:orderDetails.billingState, billingCountry:orderDetails.billingCountry, billingZip:orderDetails.billingZip]"/></else>
                </if>

                <entity-find entity-name="org.apache.ofbiz.order.order.OrderAdjustment" list="shippingTaxAdjustments">
                    <econdition field-name="orderId" from="order.orderId"/>
                    <econdition field-name="orderAdjustmentTypeId" value="SHIPPING_SALES_TAX"/>
                </entity-find>

                <if condition="shippingTaxAdjustments &amp;&amp; shippingTaxAdjustments.size() > 0">
                    <set field="shippingTaxCode" from="NetSuiteMappingWorker.getIntegrationMappingValue(ec, 'NETSUITE_TAX_CODE', 'DEFAULT')"/>
                    <else><set field="shippingTaxCode" value="-Not Taxable-"/></else>
                </if>

                <entity-find entity-name="co.hotwax.netsuite.order.NonRefundedGiftCardPayment" list="giftCardPaymentTotalList">
                    <econdition field-name="orderId" from="orderDetails.orderId"/>
                </entity-find>
                <set field="orderDetails.giftCardPaymentTotal" from="giftCardPaymentTotalList[0]?.giftCardPaymentTotal ?: BigDecimal.ZERO"/>

                <!-- Calculate total discount amount and get discount codes -->
                <entity-find entity-name="co.hotwax.order.OrderItemAdjustmentAndAttribute" list="orderDiscounts">
                    <econdition field-name="orderId" from="orderDetails.orderId"/>
                    <econdition field-name="orderAdjustmentTypeId" value="EXT_PROMO_ADJUSTMENT"/>
                    <econdition field-name="attrName" value="discount_code"/>
                </entity-find>
                <set field="totalDiscount" type="BigDecimal" default-value="0"/>
                <set field="discountCodes" from="''"/>

                <if condition="orderDiscounts">
                    <set field="totalDiscount" from="orderDiscounts.collect{ it.amount ?: 0 }.sum()" type="BigDecimal"/>
                    <set field="discountCodes" from="orderDiscounts.collect{ it.attrValue }.findAll{ it }.unique().join(', ')"/>
                </if>

                <set field="orderDetails" from="orderDetails + [orderId:orderDetails.orderName, HCOrderId:orderDetails.orderId, customer:orderDetails.netsuiteCustomerId, subsidiary:orderDetails.productStoreExternalId, salesChannel:orderDetails.orderSalesChannelDescription,
                    shopifyOrderNumber:orderDetails.orderName, HCShopifySalesOrderId:orderDetails.orderExternalId,
                    externalId: orderDetails.orderExternalId, rate:totalDiscount, discountItem:discountCodes, shippingTaxCode:shippingTaxCode]"/>

                <set field="orderItems" from="[]"/>
                <entity-find entity-name="co.hotwax.netsuite.order.OrderItemsDetails" list="orderItemsList">
                    <econdition field-name="orderId" operator="equals" from="order.orderId"/>
                </entity-find>
                <if condition="'Y'.equals(order.isMixCartOrder)">
                    <set field="shippingMethods" from="orderItemList*.shipmentMethodTypeId
                    .findAll { it &amp;&amp; it != 'POS_COMPLETED' &amp;&amp; it != 'STOREPICKUP' }.toSet()"/>
                    <set field="selectedShippingMethod" from="shippingMethods ? shippingMethods.first() : null"/>
                </if>
                <set field="grandTotal" from="order.adjustmentTotalAmount"/>

                <iterate list="orderItemsList" entry="orderItem">
                    <set field="orderItem" from="orderItem.getPlainValueMap(0)"/>
                    <entity-find entity-name="org.apache.ofbiz.order.order.OrderAdjustment" list="itemTaxAdjustments">
                        <econdition field-name="orderId" from="order.orderId"/>
                        <econdition field-name="orderItemSeqId" from="orderItem.orderItemSeqId"/>
                        <econdition field-name="orderAdjustmentTypeId" value="SALES_TAX"/>
                    </entity-find>

                    <if condition="itemTaxAdjustments &amp;&amp; itemTaxAdjustments.size() > 0">
                        <set field="taxCode" from="NetSuiteMappingWorker.getIntegrationMappingValue(ec, 'NETSUITE_TAX_CODE', 'DEFAULT')"/>
                        <else><set field="taxCode" value="-Not Taxable-"/></else>
                    </if>

                    <if condition="'Y'.equals(order.isMixCartOrder)">
                        <set field="orderDetails.shippingMethod" from="NetSuiteMappingWorker.getIntegrationMappingValue(ec, 'NETSUITE_SHP_MTHD', selectedShippingMethod)"/>
                        <else><set field="orderDetails.shippingMethod" from="NetSuiteMappingWorker.getIntegrationMappingValue(ec, 'NETSUITE_SHP_MTHD' ,orderItem.shipmentMethodTypeId)"/></else>
                    </if>
                    <set field="grandTotal" from="grandTotal + (orderItem.unitPrice * orderItem.quantity)"/>
                    <set field="closed" from="'ITEM_CANCELLED'.equalsIgnoreCase(orderItem.itemStatus)"/>
                    <set field="priceLevel" from="NetSuiteMappingWorker.getIntegrationMappingValue(ec, 'NETSUITE_PRICE_LEVEL', 'PRICE_LEVEL')" type="String"/>
                    <set field="department" from="NetSuiteMappingWorker.getFacilityDepartment(ec, orderItem.orderFacilityId)" type="String"/>

                    <entity-find entity-name="co.hotwax.facility.FacilityAndType" list="facilityAndType">
                        <econdition field-name="facilityId" from="orderItem.facilityId"/>
                        <econdition field-name="parentTypeId" operator="not-equals" value="VIRTUAL_FACILITY"/>
                    </entity-find>
                    <set field="location" from="facilityAndType[0]?.externalId ?: ''"/>

                    <set field="orderItem" from="orderItem + [item:orderItem.netsuiteProductId, lineId:orderItem.orderItemSeqId, closed:closed, priceLevel:priceLevel, department:department, location:location, itemLocation:location]"/>
                    <script>orderItems.add(orderItem)</script>

                    <!-- Process Promotions -->
                    <entity-find entity-name="co.hotwax.order.OrderItemAdjustmentAndAttribute" list="orderAdjustmentList">
                        <econdition field-name="orderId" from="order.orderId"/>
                        <econdition field-name="orderItemSeqId" from="orderItem.orderItemSeqId"/>
                        <econdition field-name="orderAdjustmentTypeId" value="EXT_PROMO_ADJUSTMENT"/>
                        <econdition field-name="attrName" operator="is-null"/>
                    </entity-find>
                    <if condition="orderAdjustmentList &amp;&amp; orderAdjustmentList.size() > 0">
                        <set field="totalPromotionAmount" from="orderAdjustmentList.collect{ it.amount }.sum()" type="BigDecimal" default-value="0"/>
                        <set field="discountRow" from="orderItem" type="NewMap"/>
                        <set field="discountRow.price" from="totalPromotionAmount"/>
                        <set field="discountRow.isDiscountRow" from="'true'"/>
                        <script>orderItems.add(promoOrderItemDetail)</script>
                    </if>
                </iterate>
                <set field="orderDetails" from="orderDetails + [HCOrderTotal:grandTotal, orderItems:orderItems]"/>
                <if condition="scriptPath">
                    <set field="orderDetails" from="ec.resource.script(scriptPath, null)"/>
                </if>
                <script>
                    def orderItems = orderDetails.remove("orderItems")
                    orderItems.each { item ->
                        item.putAll(orderDetails)
                        item.each { key, value -> item["$key"] = value }
                        item.keySet().removeAll(['productStoreExternalId', 'shippingContactMechId', 'orderSalesChannelCode', '_entity', 'billingCountryCode', 'shipmentMethodTypeId', 'billingContactNumber', 'netsuiteProductId', 'orderItemSeqId',
                            'orderSalesChannelDescription', 'productId', 'adjustmentTotalAmount', 'orderExternalId', 'netsuiteCustomerId', 'shippingContactNumber', 'billingContactMechId', 'itemStatus', 'orderName', 'facilityId', 'shippingCountryCode', 'isDiscountRow'])
                        flattenedOrders.add(item)
                    }
                    // Dynamically determine headers in the first iteration
                    if (!csvHeaders) {
                        csvHeaders = flattenedOrders[0].keySet().collect { it as String }
                        csvPrinter.printRecord(csvHeaders)
                        invalidCsvPrinter.printRecord(csvHeaders)
                    }

                    // Check for required fields and separate valid/invalid orders
                    flattenedOrders.each { record ->
                        try {
                            def schemaValidation = new co.hotwax.common.SchemaValidation(ec.ecfi ,ec)
                            schemaValidation.validateSchema(record as LinkedHashMap, schemaLocation)
                            def orderedRecord = csvHeaders.collect { key -> record[key] != null ? record[key] : "" }
                            csvPrinter.printRecord(orderedRecord)
                            isFileEmpty = false
                        } catch (Exception e) {
                            def orderedRecord = csvHeaders.collect { key -> record[key] != null ? record[key] : "" }
                            orderedRecord.add(e.message)
                            invalidCsvPrinter.printRecord(orderedRecord)
                            isReqFieldMissFileEmpty = false
                        }
                    }
                    orderDetails = null
                    flattenedOrders = []
                </script>
            </iterate>
            <script>
                  }

                }
                if (isReqFieldMissFileEmpty) {
                    invalidFile.delete()
                }
            </script>
            <if condition="!isFileEmpty">
                <!-- Save the Json Feed File path in System Message messageText -->
                <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage"
                    in-map="[systemMessageTypeId:systemMessageTypeId, systemMessageRemoteId:systemMessageRemoteId, messageText:csvFilePath]" out-map="FeedSysMsgOut"/>
            </if>
            <if condition="!isReqFieldMissFileEmpty">
                <!-- Save the Json Feed File path in System Message messageText -->
                <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage"
                    in-map="[systemMessageTypeId:relatedSystemMessageType.systemMessageTypeId, systemMessageRemoteId:systemMessageRemoteId, messageText:invalidFilePath]" out-map="MissingFieldSysMsgOut"/>
            </if>

            <return message="Generating Order Items Feed file with type ${systemMessageTypeId} and
                remote ${systemMessageRemoteId} saved response in messages ${FeedSysMsgOut?.systemMessageId} and missing file response in ${MissingFieldSysMsgOut?.systemMessageId}"/>
        </actions>
    </service>
    <service verb="consume" noun="FulfilledOrderItemFeed" authenticate="anonymous-all">
        <implements service="org.moqui.impl.SystemMessageServices.consume#SystemMessage"/>
        <actions>
            <!-- Fetch System Message -->
            <entity-find-one entity-name="moqui.service.message.SystemMessage" value-field="systemMessage"/>

            <if condition="!systemMessage.messageText">
                <return type="warning" message="System message [${systemMessageId}] for Type ${systemMessage?.systemMessageTypeId} has no message text, not consuming."/>
            </if>

            <entity-find-one entity-name="moqui.service.message.SystemMessageTypeParameter" value-field="sendSmrParam">
                <field-map field-name="systemMessageTypeId" from="systemMessage.systemMessageTypeId"/>
                <field-map field-name="parameterName" value="sendSmrId"/>
            </entity-find-one>
            <if condition="sendSmrParam">
                <set field="sendSmrId" from="sendSmrParam.parameterValue"/>
            </if>

            <if condition="sendSmrId">
                <!-- Find SystemMessageType related to systemMessage.systemMessageType to produce corresponding system message -->
                <entity-find-one entity-name="moqui.basic.Enumeration" value-field="enumValue">
                    <field-map field-name="enumId" from="systemMessage.systemMessageTypeId"/>
                </entity-find-one>

                <if condition="enumValue &amp;&amp; enumValue.relatedEnumId">
                    <entity-find-one entity-name="moqui.service.message.SystemMessageType" value-field="relatedSystemMessageType">
                        <field-map field-name="systemMessageTypeId" from="enumValue.relatedEnumId"/>
                    </entity-find-one>
                    <if condition="!relatedSystemMessageType"><log level="warn" message="Could not find SystemMessageType with ID ${enumValue.relatedEnumId}, not producing related system message."/></if>
                    <else>
                        <log level="warn" message="Related SystemMessageType to produce for ${systemMessage.systemMessageTypeId} not defined, not producing related system message."/>
                    </else>
                </if>
                <else>
                    <log level="warn" message="sendSmrId not defined for ${systemMessage.systemMessageTypeId} not defined, not producing related system message."/>
                </else>
            </if>

            <!-- Prepare JSON File Path -->
            <set field="jsonFilePathRef" from="ec.resource.expand(relatedSystemMessageType.receivePath, null,
            [contentRoot: ec.user.getPreference('mantle.content.root') ?: 'dbresource://datamanager', date:ec.l10n.format(nowDate, 'yyyy-MM-dd'), dateTime:ec.l10n.format(nowDate, 'yyyy-MM-dd-HH-mm-ss-SSS'),
             productStoreId:productStoreId], false)"/>
            <set field="jsonFilePath" from="ec.resource.getLocationReference(jsonFilePathRef).getUri().getPath()"/>

            <script><![CDATA[
            import org.apache.commons.csv.*
            import com.fasterxml.jackson.core.JsonFactory
            import com.fasterxml.jackson.core.JsonGenerator
            import com.fasterxml.jackson.databind.ObjectMapper
            import java.nio.charset.StandardCharsets

            try {
                // Prepare JSON file
                File fulfilledOrderItemJsonFile = new File(jsonFilePath)
                if (!fulfilledOrderItemJsonFile.parentFile.exists()) fulfilledOrderItemJsonFile.parentFile.mkdirs()

                JsonFactory jsonFactory = new JsonFactory()

                /* Use try-with-resources to automatically close PrintWriter & JsonGenerator */
                try (PrintWriter pw = new PrintWriter(StandardCharsets.UTF_8, fulfilledOrderItemJsonFile);
                     JsonGenerator generator = jsonFactory.createGenerator(pw)) {

                    generator.writeStartArray()
                    /* Use try-with-resources to automatically close BufferedReader & CSVParser */
                    try (BufferedReader reader = new BufferedReader(new StringReader(ec.resource.getLocationReference(systemMessage.messageText).getText()));
                         CSVParser parser = CSVFormat.DEFAULT.withFirstRecordAsHeader().parse(reader)) {

                    def orderMap = [:]

                    for (CSVRecord record : parser) {
                        def orderId = record.get("orderId")

                        shippedDate = ec.l10n.format(ec.l10n.parseDateTime(record.get("shippedDate"), "M/d/yyyy h:mm a"), "yyyy-MM-dd HH:mm:ss")

                        def orderItem = [
                            orderItemSeqId    : record.get("orderItemSeqId"),
                            externalFacilityId: record.get("externalFacilityId"),
                            shippedDate       : shippedDate ,
                            quantity          : record.get("quantity"),
                            trackingNumber    : record.get("trackingNumber") ?: "",
                            "validation-result": "success"
                        ]

                        def carrierName = record.get("shiphawkCarrierName")?.trim()?.toLowerCase()?.replaceAll("\\s+", "_") ?: ""

                        if (!orderMap.containsKey(orderId)) {
                            orderMap[orderId] = [
                                orderId           : orderId,
                                shipHawkShipmentId: record.get("shipHawkShipmentId") ?: "",
                                shiphawkCarrierName: carrierName,
                                items             : []
                            ]
                        }
                        orderMap[orderId].items << orderItem
                    }

                    // Write each order as a separate object in the JSON array
                    ObjectMapper mapper = new ObjectMapper()
                    for (orderEntry in orderMap) {
                        def orderJson = [orderMap: orderEntry.value]
                        mapper.writerWithDefaultPrettyPrinter().writeValue(generator, orderJson)
                    }
                }
                generator.writeEndArray()
                }

            } catch (IOException e) {
                logger.error("Error preparing Fulfilled Order Item Feed JSON file", e)
                ec.message.addError("Error preparing order feed file ${e}")
            }
        ]]></script>

            <if condition="relatedSystemMessageType">
                <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage"
                    in-map="[systemMessageTypeId:relatedSystemMessageType.systemMessageTypeId, systemMessageRemoteId:sendSmrId,
                        messageText:jsonFilePathRef, remoteMessageId: jsonFilePathRef.substring(jsonFilePathRef.lastIndexOf('/')+1), sendNow:true]"
                    out-map="queueSystemMessageOut" ignore-error="true" transaction="force-new"/>
            </if>

            <return message="Created the fulfilledOrderItems Feed file at time ${ec.user.nowTimestamp} with type ${relatedSystemMessageType.systemMessageTypeId}
                and remote ${sendSmrId} saved response in messages ${queueSystemMessageOut?.systemMessageId}"/>
        </actions>
    </service>

    <service verb="get" noun="FulfilledOrders" authenticate="anonymous-all" transaction-timeout="7200">
        <in-parameters>
            <parameter name="fulfilledOrdersCountPerFeed" type="Integer"/>
            <parameter name="orderId"/>
            <parameter name="orderItemSeqId"/>
            <parameter name="orderStatusId"/>
            <parameter name="systemMessageTypeId" required="true"/>
            <parameter name="systemMessageRemoteId" required="true"/>
            <parameter name="parentFacilityTypeIds" type="List"/>
            <parameter name="productTypeIds" type="List"/>
            <parameter name="productStoreIds" type="List"/>
        </in-parameters>
        <actions>
            <set field="isFirstFeed" from="true"/>
            <while condition="isFirstFeed || (fulfilledOrdersCount != null &amp;&amp; fulfilledOrdersCount > 0 &amp;&amp; fulfilledOrdersCount == fulfilledOrdersCountPerFeed)">
                <service-call name="co.hotwax.netsuite.OrderServices.generate#FulfilledOrderItemsFeed"
                              in-map="context" out-map="fulfilledFeedOut" transaction="force-new"/>
                <set field="fulfilledOrdersCount" from="fulfilledFeedOut?.fulfilledFeedOrdersCount"/>
                <set field="isFirstFeed" from="false"/>
            </while>
        </actions>
    </service>
    <service verb="generate" noun="FulfilledOrderItemsFeed" authenticate="anonymous-all" transaction-timeout="7200">
        <in-parameters>
            <parameter name="systemMessageRemoteId" required="true"/>
            <parameter name="systemMessageTypeId" required="true"/>
            <parameter name="fulfilledOrdersCountPerFeed" type="Integer"/>
            <parameter name="orderId"/>
            <parameter name="orderItemSeqId"/>
            <parameter name="orderStatusId"/>
            <parameter name="orderTypeId" default-value="SALES_ORDER"/>
            <parameter name="parentFacilityTypeIds" type="List"/>
            <parameter name="productTypeIds" type="List"/>
            <parameter name="productStoreIds" type="List"/>
        </in-parameters>
        <out-parameters>
            <parameter name="fulfilledFeedOrdersCount" type="Integer"/>
        </out-parameters>
        <actions>
            <set field="fulfilledFeedOrdersCount" from="0"/>
            <set field="nowDate" from="ec.user.nowTimestamp"/>
            <script>
            import org.moqui.entity.EntityCondition
            import com.fasterxml.jackson.core.JsonFactory
            import com.fasterxml.jackson.core.JsonGenerator
            import com.fasterxml.jackson.databind.ObjectMapper
            import java.nio.file.Files
            import java.nio.file.Paths
            import java.nio.charset.StandardCharsets
            import java.text.SimpleDateFormat
            import java.io.File

            def fulfilledOrdersItems = ec.entity.find("co.hotwax.netsuite.warehouse.FulfilledOrderItemsSyncQueue")
                .condition("itemStatusId", "ITEM_COMPLETED")
                .condition("orderTypeId", orderTypeId)

            if (orderId) fulfilledOrdersItems.condition("orderId", orderId)
            if (orderItemSeqId) fulfilledOrdersItems.condition("orderItemSeqId", orderItemSeqId)
            if (orderStatusId) fulfilledOrdersItems.condition("orderStatusId", orderStatusId)
            if (parentFacilityTypeIds) fulfilledOrdersItems.condition("parentFacilityTypeId", EntityCondition.ComparisonOperator.IN, parentFacilityTypeIds)
            if (productStoreIds) fulfilledOrdersItems.condition("productStoreId", EntityCondition.ComparisonOperator.IN, productStoreIds)
            if (productTypeIds) fulfilledOrdersItems.condition("productTypeId", EntityCondition.ComparisonOperator.IN, productTypeIds)

            fulfilledOrdersItems.selectField("orderId,productStoreId,shopId")
                .orderBy("statusDatetime")

            //If no eligible fulfilled orders, then don't generate the file
            long fulfilledOrdersCount = fulfilledOrdersItems.count()
            if (fulfilledOrdersCount == 0) {
                ec.message.addMessage("No eligible orders for Fulfilled Order and Items Feed at ${nowDate}, not generating the HotWax Feed file.")
                return
            }

            try (fulfilledOrdersItemsItr = fulfilledOrdersItems.iterator()) {
            </script>

            <set field="productStoreId" from="(!productStoreIds || productStoreIds.size() != 1) ? System.getProperty('hotwax_feed_default_prefix') : productStoreIds[0]"/>

            <entity-find-one entity-name="moqui.service.message.SystemMessageType" value-field="systemMessageType">
                <field-map field-name="systemMessageTypeId" value="${systemMessageTypeId}"/>
            </entity-find-one>
            <if condition="systemMessageType == null">
                <return error="true" message="Could not find SystemMessageType with ID ${systemMessageTypeId}"/>
            </if>
            <set field="jsonFilePathRef" from="ec.resource.expand(systemMessageType.receivePath, null,
                [contentRoot: ec.user.getPreference('mantle.content.root') ?: 'dbresource://datamanager',
                 date: ec.l10n.format(nowDate, 'yyyy-MM-dd'),
                 dateTime: ec.l10n.format(nowDate, 'yyyy-MM-dd-HH-mm-ss-SSS'),
                 productStoreId: productStoreId,
                 shopId: customParametersMap?.shopId], false)"/>

            <set field="jsonFilePath" from="ec.resource.getLocationReference(jsonFilePathRef).getUri().getPath()"/>

            <script><![CDATA[
                File fulfilledOrderItemsFeedFile = new File(jsonFilePath)
                if (!fulfilledOrderItemsFeedFile.parentFile.exists()) fulfilledOrderItemsFeedFile.parentFile.mkdirs()

                JsonFactory jfactory = new JsonFactory()
                ObjectMapper objectMapper = new ObjectMapper()
                objectMapper.setDateFormat(new SimpleDateFormat(System.getProperty('default_date_time_format')))

                def path = Paths.get(jsonFilePath)
                try(def writer = Files.newBufferedWriter(path, StandardCharsets.UTF_8)
                JsonGenerator jGenerator = jfactory.createGenerator(writer)){
                    jGenerator.writeStartArray()
            ]]></script>
            <set field="jsonSlurper" from="new groovy.json.JsonSlurper()"/>
            <iterate list="fulfilledOrdersItemsItr" entry="fulfilledOrderItem">
                <entity-find entity-name="co.hotwax.netsuite.warehouse.FulfilledOrderItemsSyncQueue" list="fulfilledOrderItem">
                    <econdition field-name="orderId" from="fulfilledOrderItem.orderId"/>
                    <order-by field-name="orderItemSeqId"/>
                </entity-find>

                <entity-find-one entity-name="moqui.service.message.SystemMessageTypeParameter" value-field="ftlFileResource">
                    <field-map field-name="systemMessageTypeId" from="systemMessageTypeId"/>
                    <field-map field-name="parameterName" value="resourcePath"/>
                </entity-find-one>
                <!-- Check if the custom ftl file resource is available. -->
                <if condition="ftlFileResource &amp;&amp; ftlFileResource.parameterValue">
                    <set field="templateLocation" from="ftlFileResource.parameterValue"/>
                    <else><set field="templateLocation" value="component://mantle-netsuite-connector/template/FulfilledOrderItemsFeedDetail.ftl"/></else>
                </if>
                <set field="templateWriter" from="new StringWriter()"/>
                <script>ec.resourceFacade.template(templateLocation, templateWriter)</script>
                <set field="fulfilledOrderItemMap" from="jsonSlurper.parseText(templateWriter.toString())"/>

                <iterate list="fulfilledOrderItem" entry="item">
                    <service-call name="create#co.hotwax.integration.order.OrderFulfillmentHistory"
                        in-map="[orderId:item.orderId, orderItemSeqId:item.orderItemSeqId, comments:'Order Item sent as part of Fulfilled Items Feed', createdDate:nowDate, externalFulfillmentId:'_NA_']"/>
                </iterate>

                <script>
                    objectMapper.writerWithDefaultPrettyPrinter().writeValue(jGenerator, fulfilledOrderItemMap)
                    fulfilledFeedOrdersCount = (fulfilledFeedOrdersCount ?: 0) + 1
                </script>
            </iterate>
            <script>
                    jGenerator.writeEndArray()
                }
            }
            </script>
            <if condition="fulfilledFeedOrdersCount != 0">
                <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage"
                    in-map="[systemMessageTypeId:systemMessageTypeId, systemMessageRemoteId:systemMessageRemoteId,
                    messageText:jsonFilePathRef, productStoreId:productStoreId, shopId:customParametersMap?.shopId]"
                    out-map="fulfillmentFeedSysMsgOut"/>
            </if>
            <return message="Completed Fulfilled Order Items Feed file with ${fulfilledFeedOrdersCount} at time ${ec.user.nowTimestamp} with type ${systemMessageTypeId} and
                remote ${systemMessageRemoteId} saved response in messages ${fulfillmentFeedSysMsgOut?.systemMessageId}"/>
        </actions>
    </service>
    <service verb="get" noun="BrokeredOrders" authenticate="anonymous-all" transaction-timeout="7200">
        <in-parameters>
            <parameter name="brokeredOrdersCountPerFeed" type="Integer"/>
            <parameter name="orderId"/>
            <parameter name="orderItemSeqId"/>
            <parameter name="systemMessageTypeId" required="true"/>
            <parameter name="systemMessageRemoteId" required="true"/>
            <parameter name="parentFacilityTypeIds" type="List"/>
            <parameter name="productStoreIds" type="List"/>
            <parameter name="facilityGroupIds" type="List"/>
        </in-parameters>
        <actions>
            <set field="isFirstFeed" from="true"/>
            <while condition="isFirstFeed || (brokeredOrdersCount &amp;&amp; (brokeredOrdersCount == brokeredOrdersCountPerFeed || brokeredOrdersCount != 0))">
                <!-- Added transaction=force-new as for each call to this service should be done in a new transaction
                     so that if there are multiple files being generated and an error occurs for an order in one file then
                     the transaction should be rolled back only for that file and not all the files. -->

                <!-- NOTE: Without a new transaction, if an error occurs for an order, then the whole transaction is rolled back
                     that means, no history will be created for any orders in previous generated files but the previous generated files will be sent to SFTP.
                     This can result into duplicate orders as the previous files were sent to SFTP and since history was not created
                     so these orders will be eligible and will come again in the feed. -->

                <service-call name="co.hotwax.netsuite.OrderServices.generate#BrokeredOrderItemsFeed"
                              in-map="context" out-map="brokeredFeedOut" transaction="force-new"/>
                <set field="brokeredOrdersCount" from="brokeredFeedOut?.brokeredFeedOrdersCount"/>

                <!-- Negated the value for while condition for next runs -->
                <set field="isFirstFeed" from="false"/>
            </while>
        </actions>
    </service>
    <service verb="generate" noun="BrokeredOrderItemsFeed" authenticate="anonymous-all" transaction-timeout="7200">
        <description>
            Service to generate Brokered Order Items Feed for the new order sync flow with added check for NetsuiteItemLineId and takes count per feed which can take in a limit parameter
            to include a specific number of records in the Feed File.
            If no limit is set, default-value of limit parameter will be considered to fetch the
            eligible orders for the feed.
        </description>
        <in-parameters>
            <parameter name="brokeredOrdersCountPerFeed" type="Integer"/>
            <parameter name="orderId"/>
            <parameter name="orderItemSeqId"/>
            <parameter name="systemMessageTypeId" required="true"/>
            <parameter name="systemMessageRemoteId" required="true"/>
            <parameter name="parentFacilityTypeIds" type="List"/>
            <parameter name="facilityGroupIds" type="List"/>
            <parameter name="productStoreIds" type="List"/>
        </in-parameters>
        <out-parameters>
            <parameter name="brokeredFeedOrdersCount" type="Integer"/>
        </out-parameters>
        <actions>

            <set field="brokeredFeedOrdersCount" from="0"/>
            <set field="nowDate" from="ec.user.nowTimestamp"/>

            <log message="Generating Brokered Orders and Items Feed Feed file of HotWax for parentFacilityTypeId ${parentFacilityTypeIds}, Order ${orderId} at time ${nowDate}"/>

            <entity-find-one entity-name="moqui.service.message.SystemMessageType" value-field="systemMessageType"/>
            <if condition="systemMessageType == null"><return error="true" message="Could not find SystemMessageType with ID ${systemMessageTypeId}"/></if>

            <set field="productStoreId" from="(!productStoreIds || productStoreIds.size() > 1) ? System.getProperty('hotwax_feed_default_prefix') : productStoreIds[0]"/>

            <set field="csvFilePathRef" from="ec.resource.expand(systemMessageType.receivePath, null,
                [contentRoot: ec.user.getPreference('mantle.content.root') ?: 'dbresource://datamanager', date:ec.l10n.format(nowDate, 'yyyy-MM-dd'), dateTime:ec.l10n.format(nowDate, 'yyyy-MM-dd-HH-mm-ss-SSS'),
                productStoreId:productStoreId], false)"/>

            <set field="csvFilePath" from="ec.resource.getLocationReference(csvFilePathRef).getUri().getPath()"/>

            <script>
                import org.apache.commons.csv.CSVFormat
                import org.apache.commons.csv.CSVPrinter
                import java.nio.file.Files
                import java.nio.file.Paths
                import java.nio.charset.StandardCharsets
                import org.moqui.entity.EntityCondition

                File csvFile = new File(csvFilePath)
                if(!csvFile.parentFile.exists()) csvFile.parentFile.mkdirs()
                def isFileEmpty = true
                def csvHeaders = null

                brokeredOrders_find = ec.entity.find("co.hotwax.netsuite.warehouse.BrokeredOrderItemsFeed").distinct(true)
                brokeredOrders_find.condition("itemStatusId", "ITEM_APPROVED")
                if(orderId) brokeredOrders_find.condition("orderId", orderId)
                if(orderItemSeqId) brokeredOrders_find.condition("orderItemSeqId", orderItemSeqId)
                if(facilityGroupIds) brokeredOrders_find.condition("facilityGroupId", EntityCondition.ComparisonOperator.IN, facilityGroupIds)
                if(productStoreIds) brokeredOrders_find.condition("productStoreId", EntityCondition.ComparisonOperator.IN, productStoreIds)
                brokeredOrders_find.limit(brokeredOrdersCountPerFeed)
                .selectField("orderId,entryDate,netsuiteItemLineId,orderItemSeqId,productStoreId,productId,shipmentMethodTypeId,facilityExternalId,postalContactMechId,itemStatusId,externalFulfillmentOrderItemId,shipGroupSeqId,orderItemQuantity")
                .orderBy("entryDate")

                //If no eligible brokered orders, then don't generate the file
                long brokeredOrdersCount = brokeredOrders_find.count()
                if (brokeredOrdersCount == 0) {
                    ec.message.addMessage("No eligible orders for Brokered Order and Items Feed at ${nowDate}, not generating the HotWax Feed file.")
                    return
                }

                try (brokeredOrdersItr = brokeredOrders_find.iterator()) {
                    try (def writer = Files.newBufferedWriter(Paths.get(csvFilePath), StandardCharsets.UTF_8);
                    def csvPrinter = new CSVPrinter(writer, CSVFormat.DEFAULT)){
            </script>

            <iterate list="brokeredOrdersItr" entry="brokerOrderItem">
                <set field="jsonSlurper" from="new groovy.json.JsonSlurper()"/>

                <entity-find-one entity-name="moqui.service.message.SystemMessageTypeParameter" value-field="ftlFileResource">
                    <field-map field-name="systemMessageTypeId" from="systemMessageTypeId"/>
                    <field-map field-name="parameterName" value="resourcePath"/>
                </entity-find-one>
                <!-- Check if the custom ftl file resource is available. -->
                <if condition="ftlFileResource &amp;&amp; ftlFileResource.parameterValue">
                    <set field="templateLocation" from="ftlFileResource.parameterValue"/>
                    <else><set field="templateLocation" value="component://mantle-netsuite-connector/template/GetBrokeredOrderItemsDetail.ftl"/></else>
                </if>
                <set field="templateWriter" from="new StringWriter()"/>
                <script>ec.resourceFacade.template(templateLocation, templateWriter)</script>
                <set field="brokerOrderItemMap" from="jsonSlurper.parseText(templateWriter.toString())"/>

                <if condition="brokerOrderItem.externalFulfillmentOrderItemId"><then>
                    <service-call name="update#co.hotwax.integration.order.ExternalFulfillmentOrderItem"
                        in-map="[externalFulfillmentOrderItemId:brokerOrderItem.externalFulfillmentOrderItemId,
                        fulfillmentStatus:'Sent']"/>
                </then><else>
                    <service-call name="create#co.hotwax.integration.order.ExternalFulfillmentOrderItem" in-map="[orderId:brokerOrderItem.orderId,
                        orderItemSeqId:brokerOrderItem.orderItemSeqId, shipGroupSeqId:brokerOrderItem.shipGroupSeqId,
                        fulfillmentStatus:'Sent', createdDate:nowDate, quantity:brokerOrderItem.orderItemQuantity]"/>
                </else></if>

                <if condition="!csvHeaders">
                    <set field="csvHeaders" from="brokerOrderItemMap.keySet().toList()"/>
                    <script>csvPrinter.printRecord(csvHeaders)</script>
                </if>
                <set field="brokerOrderItemRecord" from="csvHeaders.collect { key -> brokerOrderItemMap[key] != null ? brokerOrderItemMap[key] : '' }"/>
                <script>
                    csvPrinter.printRecord(brokerOrderItemRecord)
                    brokeredFeedOrdersCount++
                </script>
            </iterate>
            <script>
                }
                    } catch (Exception e) {
                        ec.message.addError("Error preparing brokered order feed file ${e}")
                }
            </script>
            <if condition="brokeredFeedOrdersCount != 0">
                <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage"
                    in-map="[messageText:csvFilePathRef, systemMessageTypeId:systemMessageTypeId,
                    systemMessageRemoteId:systemMessageRemoteId, productStoreId:productStoreId]" out-map="brokeredSystemMessageOut"/>
            </if>

            <return message="Created the Brokered Order Items Feed file with orders count
                ${brokeredFeedOrdersCount} at time ${ec.user.nowTimestamp} with type ${systemMessageTypeId}
                and remote ${systemMessageRemoteId} saved response in messages
                ${brokeredSystemMessageOut?.systemMessageId}"/>
        </actions>
    </service>
</services>
